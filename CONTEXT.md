# Orpheon Protocol
> **The Intent-Native Interaction Standard for Autonomous Systems**

| Version | Status | Implementation Language | License |
| :--- | :--- | :--- | :--- |
| 1.0.0-alpha | **Specification** | **Rust** (Official) | MIT / Apache 2.0 |

---

## 1. Abstract

**Orpheon** destroys the rigid "Request/Response" paradigm of the last two decades. It introduces a new interaction model designed specifically for **AI Agents**, **Autonomous Orchestrators**, and **High-Reliability Systems**.

In traditional REST/GraphQL APIs, clients are responsible for *orchestration* (calling endpoints in order, handling errors, polling for state). In Orpheon, the client declares an **Intent** (what they want), and the server (the Orpheon Node) takes responsibility for the **Plan** (how to get there).

This document outlines the Orpheon Protocol, its core primitives, and its reference implementation in **Rust**.

---

## 2. Why Rust?

Orpheon is designed to be the backbone of mission-critical autonomous agents. Therefore, the implementation language was chosen not for ease of prototyping, but for **correctness, concurrency, and performance**.

### 2.1 The Safety Guarantees
*   **Memory Safety**: Orpheon nodes handle thousands of concurrent state simulations and negotiations. Rustâ€™s ownership model ensures we never face race conditions or segmentation faults during complex state mutations.
*   **Type System as Contract**: We leverage Rust's Affine Types to model linear state transitionsâ€”an intent cannot be "executed" twice; the type system physically prevents it.

### 2.2 Performance
*   **Zero-Cost Abstractions**: The *Planner* module uses complex heuristic search algorithms. Rust allows us to implement high-level abstractions for these algorithms without the runtime penalty of Garbage Collection.
*   **Async Runtime**: Built on top of `tokio`, Orpheon handles massive concurrency (100k+ active intents) with minimal overhead, critical for high-frequency negotiation environments.

### 2.3 WASM Portability
*   **Edge Planning**: The Orpheon Planner (written in Rust) compiles to WebAssembly (WASM), allowing clients to run "pre-flight" simulations in the browser or on edge devices before submitting intents to the mesh.

---

## 3. Core Primitives (The Rust Type System)

The Protocol is defined by its data structures. Below are the canonical Rust definitions for the core primitives.

### 3.1 The Intent (`Intent<T>`)
An Intent is a declaration of a desired future state. It is **immutable** once signed.

```rust
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Intent {
    pub id: Uuid,
    /// The semantic type of the intent (e.g., "fulfill_order", "book_flight")
    pub kind: String,
    
    /// Hard constraints that MUST be met.
    pub constraints: Vec<Constraint>,
    
    /// Optimization preferences (e.g., Minimize Cost vs Minimize Latency).
    pub preferences: Vec<Preference>,
    
    /// The budget allowed for this execution (Time + Money).
    pub budget: Budget,
    
    /// The temporal window in which this intent is valid.
    pub validity_window: TimeWindow,
    
    /// Cryptographic signature of the issuer.
    pub signature: Signature,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum Constraint {
    /// E.g. "region == 'US-EAST'"
    StateMatch(String),
    /// E.g. "total_cost < 5.00"
    ResourceLimit { resource: String, limit: f64 },
    /// E.g. "latency < 200ms"
    SLA { metric: String, threshold: u64 },
}
```

### 3.2 The Plan (`Plan`)
A Plan is a directed acyclic graph (DAG) of steps generated by the Planner to satisfy an Intent.

```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Plan {
    pub intent_id: Uuid,
    pub steps: Vec<Step>,
    pub estimated_cost: f64,
    pub estimated_latency_ms: u64,
    pub confidence_score: f32, // 0.0 to 1.0
    pub strategy: PlanningStrategy,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlanningStrategy {
    Deterministic, // Rule-based
    Heuristic,     // A* search / optimization
    Generative,    // LLM/AI-driven
}
```

### 3.3 The Execution Artifact (`Artifact`)
Orpheon provides "Proof of Outcome". When an intent is finalized, an immutable artifact is generated.

```rust
#[derive(Serialize, Deserialize, Debug)]
pub struct ExecutionArtifact {
    pub intent: Intent,
    pub final_plan: Plan,
    pub trace: Vec<ExecutionEvent>,
    pub outcome: Outcome,
    pub timestamp: DateTime<Utc>,
    /// Merkle root of the execution trace for verifiable logging
    pub merkle_root: String,
}
```

---

## 4. The Architecture

The Orpheon Node is a modular system composed of four engines.

```mermaid
graph TD
    Client -->|Submits Intent| Ingress
    Ingress --> Engine
    
    subgraph Orpheon Node
        Engine[Engine Core]
        Planner[Planner (Heuristic/AI)]
        Neg[Negotiation Module]
        State[Temporal State Store]
        
        Engine -->|Requests Plan| Planner
        Planner -->|Reads State| State
        Planner -->|Returns Plan| Engine
        
        Engine -->|Proposes Contract| Neg
        Neg <-->|Bidirectional Stream| Client
        
        Engine -->|Executes| Executors
    end
    
    Executors -->|Updates| State
    State -->|Push Changes| Client
```

### 4.1 The Planner
*   **Role**: Determines *how* to fulfill an intent.
*   **Logic**:
    1.  Receives `Intent`.
    2.  Simulates potential execution paths against the `Temporal State Store`.
    3.  Prunes paths that violate `Constraints`.
    4.  Ranks paths based on `Preferences`.
    5.  Returns the optimal `Plan`.

### 4.2 The Negotiation Module
*   **Role**: Handles the dynamic agreement between Client and Server.
*   **Transport**: WebSocket / QUIC.
*   **Protocol**:
    1.  Server offers a `Plan` with cost `X` and SLA `Y`.
    2.  Client counter-offers (e.g., "I need it cheaper, I can wait longer").
    3.  Server re-optimizes and accepts/rejects.

### 4.3 The Temporal State Store
*   **Role**: A time-travel capable database.
*   **Features**:
    *   **Append-Only**: No data is ever overwritten.
    *   **branching**: Simulations run on "forks" of the state tree.
    *   **Subscribable**: Supports complex boolean watch expressions (SEL - State Expression Language).

---

## 5. Advanced Features

### 5.1 Speculative Execution (Time Travel)
Orpheon allows clients to query the *future*.

**Usage:**
```bash
orp --intent "scale_cluster" --simulate --time "2025-12-01"
```

**How it works**:
1.  The State Store creates a "Copy-on-Write" fork of the current state.
2.  The Planner executes the intent against this virtual state.
3.  The resulting state changes and side effects are returned as a `SimulationReport`.
4.  No actual resources are consumed.

### 5.2 Recursive Intents (Atomic Composability)
An intent can spawn child intents. This allows for fractal complexity handling.

*   **Parent Intent**: `Organize Conference`
    *   **Child Intent A**: `Book Venue`
    *   **Child Intent B**: `Order Catering`
    *   **Child Intent C**: `Notify Speakers`

If Child Intent B fails (no food available), the Parent Intent fails, and Child Intent A (Booking) is automatically rolled back (via compensation logic) by the Protocol.

### 5.3 Zero-Knowledge Auditing
For enterprise/privacy use cases, Orpheon supports ZK-proofs.
*   A client can verify that a plan executed correctly and met all constraints *without* seeing the underlying data or sensitive internal steps.

### 5.4 Federated Execution (The Mesh)
Multiple Orpheon Nodes can form a mesh.
*   If Node A cannot fulfill an Intent (due to load or lack of capability), it can *subcontract* the Intent to Node B.
*   The Client interacts only with Node A; the complexity of the mesh is abstracted.

---

## 6. Interaction Lifecycle (Example)

**Scenario**: An AI Agent needs to provision a GPU cluster for training, but has a strict budget.

### Step 1: Intent Submission
The Agent constructs an Intent using the Rust SDK:

```rust
let intent = Intent::builder()
    .kind("provision_infrastructure")
    .constraint("gpu_type", "H100")
    .constraint("cluster_size", "8")
    .constraint("region", "any")
    .budget(Budget::usd(50.00)) // Low budget!
    .build();

client.submit(intent).await?;
```

### Step 2: Planning & Validation
The Orpheon Node validates the intent. The Planner looks at available resources.
*   *Direct Path*: AWS US-EAST (Too expensive, exceeds budget).
*   *Alternative Path*: Spot Instances on Azure (Fits budget, but lower reliability).

### Step 3: Negotiation
The Server responds:
> "I cannot provide On-Demand H100s for $50. However, I can provide Spot Instances with a 5% preemption risk."

The Agent's logic evaluates this risk and accepts.

### Step 4: Execution & Observation
The steps bloom into actual API calls to cloud providers.
The Agent does **not** poll. It subscribes:

```rust
client.watch("infrastructure.status == 'ready'", |event| {
    println!("Cluster is ready: {:?}", event);
}).await;
```

### Step 5: Artifact Generation
Once complete, the Agent receives an `ExecutionArtifact`. This is a cryptographically signed receipt proving that 8 H100s were provisioned at the agreed price.

---

## 7. Comparison Overview

| Feature | REST / OpenAPI | GraphQL | Orpheon Protocol |
| :--- | :--- | :--- | :--- |
| **Primary Unit** | Resource Endpoint | Data Query | **Intent** |
| **Responsibility**| Client (Do this, then that) | Client (Fetch this) | **Server** (Plan & Execute) |
| **State** | Polling / Webhooks | Subscription (limited) | **Real-time State Sync** |
| **Time** | Instantaneous | Instantaneous | **Temporal (Past/Future)** |
| **Failure** | Exception / Error Code | Error Field | **Compensation / Rollback** |
| **Typing** | JSON Schema | Schema Language | **Rust Type System** |
| **AI Ready?** | No (Too granular) | No (Data only) | **Native (Outcome based)** |

---

## 8. Implementation Roadmap

### Phase 1: Core (Current)
- [x] Rust SDK (`orpheon-sdk`)
- [x] Basic Planner (A* implementation)
- [x] In-Memory State Store
- [ ] Spec: `Intent` definition v1.0

### Phase 2: Distribution
- [ ] Persistent storage (Postgres/Sled backend)
- [ ] P2P Negotiation Protocol
- [ ] WASM Planner compilation

### Phase 3: Ecosystem
- [ ] Language bindings (Python, TS)
- [ ] "Orpheon Studio" (Visual debugger)
- [ ] Standard Intent Library (Common tasks)

---

> Built with ðŸ¦€ Rust. Designed for the Autonomous Future.
