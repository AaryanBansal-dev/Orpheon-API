//! Plan types for the Orpheon Protocol.
//!
//! A Plan is a directed acyclic graph (DAG) of Steps generated by the Planner.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::error::{OrpheonError, Result};

/// A Plan is a DAG of steps to satisfy an Intent.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Plan {
    /// Unique identifier for this plan.
    pub id: Uuid,

    /// The intent this plan fulfills.
    pub intent_id: Uuid,

    /// Ordered list of execution steps (topologically sorted).
    pub steps: Vec<Step>,

    /// Estimated total cost of execution.
    pub estimated_cost: f64,

    /// Estimated total latency in milliseconds.
    pub estimated_latency_ms: u64,

    /// Confidence score (0.0 to 1.0) based on historical success.
    pub confidence_score: f32,

    /// Strategy used to generate this plan.
    pub strategy: PlanningStrategy,

    /// When this plan was generated.
    pub created_at: DateTime<Utc>,

    /// When this plan expires (must be executed before).
    pub expires_at: Option<DateTime<Utc>>,

    /// Version for optimistic concurrency.
    pub version: u32,
}

/// A single step in an execution plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Step {
    /// Unique identifier for this step.
    pub id: Uuid,

    /// Human-readable name for this step.
    pub name: String,

    /// The action to perform (e.g., "allocate_resource", "invoke_api").
    pub action: String,

    /// Parameters for the action.
    pub parameters: serde_json::Value,

    /// Dependencies - step IDs that must complete before this step.
    pub dependencies: Vec<Uuid>,

    /// Estimated duration in milliseconds.
    pub estimated_duration_ms: u64,

    /// Estimated cost for this step.
    pub estimated_cost: f64,

    /// Compensation action to run if rollback is needed.
    pub compensate: Option<CompensationAction>,

    /// Whether this step can be retried on failure.
    pub retryable: bool,

    /// Maximum number of retry attempts.
    pub max_retries: u32,

    /// Timeout in milliseconds (None = no timeout).
    pub timeout_ms: Option<u64>,
}

/// Compensation action for rollback.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompensationAction {
    /// The action to perform for compensation.
    pub action: String,

    /// Parameters for the compensation action.
    pub parameters: serde_json::Value,
}

/// Strategy used to generate a plan.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum PlanningStrategy {
    /// Rule-based deterministic planning.
    #[default]
    Deterministic,

    /// Heuristic-based (A* search, optimization).
    Heuristic,

    /// AI/LLM-driven generative planning.
    Generative,

    /// Monte-Carlo tree search for probabilistic planning.
    MonteCarlo,

    /// Hybrid approach combining multiple strategies.
    Hybrid,
}

impl Plan {
    /// Create a new plan for an intent.
    pub fn new(intent_id: Uuid, strategy: PlanningStrategy) -> Self {
        Self {
            id: Uuid::new_v4(),
            intent_id,
            steps: Vec::new(),
            estimated_cost: 0.0,
            estimated_latency_ms: 0,
            confidence_score: 0.0,
            strategy,
            created_at: Utc::now(),
            expires_at: None,
            version: 1,
        }
    }

    /// Add a step to the plan.
    pub fn add_step(&mut self, step: Step) {
        self.estimated_cost += step.estimated_cost;
        // Only add duration if no dependencies (critical path estimation is simplified)
        if step.dependencies.is_empty() {
            self.estimated_latency_ms += step.estimated_duration_ms;
        }
        self.steps.push(step);
    }

    /// Validate the plan (check for cycles, missing dependencies).
    pub fn validate(&self) -> Result<()> {
        // Check for duplicate step IDs
        let mut seen_ids = std::collections::HashSet::new();
        for step in &self.steps {
            if !seen_ids.insert(step.id) {
                return Err(OrpheonError::PlanningFailed {
                    intent_id: self.intent_id,
                    message: format!("Duplicate step ID: {}", step.id),
                });
            }
        }

        // Check for missing dependencies
        for step in &self.steps {
            for dep_id in &step.dependencies {
                if !seen_ids.contains(dep_id) {
                    return Err(OrpheonError::PlanningFailed {
                        intent_id: self.intent_id,
                        message: format!(
                            "Step {} depends on unknown step {}",
                            step.id, dep_id
                        ),
                    });
                }
            }
        }

        // Check for cycles using DFS
        if self.has_cycle() {
            return Err(OrpheonError::PlanningFailed {
                intent_id: self.intent_id,
                message: "Plan contains a dependency cycle".to_string(),
            });
        }

        Ok(())
    }

    /// Check if the plan DAG has a cycle.
    fn has_cycle(&self) -> bool {
        use std::collections::{HashMap, HashSet};

        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();

        // Build adjacency list
        let adj: HashMap<Uuid, Vec<Uuid>> = self
            .steps
            .iter()
            .map(|s| (s.id, s.dependencies.clone()))
            .collect();

        fn dfs(
            node: Uuid,
            adj: &HashMap<Uuid, Vec<Uuid>>,
            visited: &mut HashSet<Uuid>,
            rec_stack: &mut HashSet<Uuid>,
        ) -> bool {
            visited.insert(node);
            rec_stack.insert(node);

            if let Some(deps) = adj.get(&node) {
                for &dep in deps {
                    if !visited.contains(&dep) {
                        if dfs(dep, adj, visited, rec_stack) {
                            return true;
                        }
                    } else if rec_stack.contains(&dep) {
                        return true;
                    }
                }
            }

            rec_stack.remove(&node);
            false
        }

        for step in &self.steps {
            if !visited.contains(&step.id) {
                if dfs(step.id, &adj, &mut visited, &mut rec_stack) {
                    return true;
                }
            }
        }

        false
    }

    /// Get the entry points (steps with no dependencies).
    pub fn entry_points(&self) -> Vec<&Step> {
        self.steps.iter().filter(|s| s.dependencies.is_empty()).collect()
    }

    /// Get the exit points (steps that no other step depends on).
    pub fn exit_points(&self) -> Vec<&Step> {
        use std::collections::HashSet;

        let depended_on: HashSet<Uuid> = self
            .steps
            .iter()
            .flat_map(|s| s.dependencies.iter().copied())
            .collect();

        self.steps
            .iter()
            .filter(|s| !depended_on.contains(&s.id))
            .collect()
    }

    /// Topologically sort the steps.
    pub fn topological_sort(&self) -> Vec<&Step> {
        use std::collections::{HashMap, HashSet, VecDeque};

        let mut in_degree: HashMap<Uuid, usize> = HashMap::new();
        let mut dependents: HashMap<Uuid, Vec<Uuid>> = HashMap::new();
        let step_map: HashMap<Uuid, &Step> = self.steps.iter().map(|s| (s.id, s)).collect();

        // Initialize
        for step in &self.steps {
            in_degree.entry(step.id).or_insert(0);
            for &dep in &step.dependencies {
                dependents.entry(dep).or_default().push(step.id);
                *in_degree.entry(step.id).or_insert(0) += 1;
            }
        }

        // Kahn's algorithm
        let mut queue: VecDeque<Uuid> = in_degree
            .iter()
            .filter(|(_, &deg)| deg == 0)
            .map(|(&id, _)| id)
            .collect();

        let mut result = Vec::new();

        while let Some(id) = queue.pop_front() {
            if let Some(&step) = step_map.get(&id) {
                result.push(step);
            }

            if let Some(deps) = dependents.get(&id) {
                for &dep_id in deps {
                    if let Some(deg) = in_degree.get_mut(&dep_id) {
                        *deg -= 1;
                        if *deg == 0 {
                            queue.push_back(dep_id);
                        }
                    }
                }
            }
        }

        result
    }
}

impl Step {
    /// Create a new step.
    pub fn new(name: impl Into<String>, action: impl Into<String>) -> Self {
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            action: action.into(),
            parameters: serde_json::Value::Null,
            dependencies: Vec::new(),
            estimated_duration_ms: 0,
            estimated_cost: 0.0,
            compensate: None,
            retryable: true,
            max_retries: 3,
            timeout_ms: None,
        }
    }

    /// Set step parameters.
    pub fn with_parameters(mut self, params: serde_json::Value) -> Self {
        self.parameters = params;
        self
    }

    /// Add a dependency.
    pub fn depends_on(mut self, step_id: Uuid) -> Self {
        self.dependencies.push(step_id);
        self
    }

    /// Set estimated duration.
    pub fn with_duration(mut self, duration_ms: u64) -> Self {
        self.estimated_duration_ms = duration_ms;
        self
    }

    /// Set estimated cost.
    pub fn with_cost(mut self, cost: f64) -> Self {
        self.estimated_cost = cost;
        self
    }

    /// Set compensation action.
    pub fn with_compensation(mut self, action: impl Into<String>, params: serde_json::Value) -> Self {
        self.compensate = Some(CompensationAction {
            action: action.into(),
            parameters: params,
        });
        self
    }

    /// Set timeout.
    pub fn with_timeout(mut self, timeout_ms: u64) -> Self {
        self.timeout_ms = Some(timeout_ms);
        self
    }

    /// Mark as non-retryable.
    pub fn non_retryable(mut self) -> Self {
        self.retryable = false;
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_creation() {
        let intent_id = Uuid::new_v4();
        let plan = Plan::new(intent_id, PlanningStrategy::Heuristic);
        assert_eq!(plan.intent_id, intent_id);
        assert!(plan.steps.is_empty());
    }

    #[test]
    fn test_step_builder() {
        let step = Step::new("Allocate Resources", "allocate")
            .with_duration(1000)
            .with_cost(5.0)
            .with_timeout(30000);

        assert_eq!(step.name, "Allocate Resources");
        assert_eq!(step.action, "allocate");
        assert_eq!(step.estimated_duration_ms, 1000);
        assert_eq!(step.timeout_ms, Some(30000));
    }

    #[test]
    fn test_plan_validation() {
        let intent_id = Uuid::new_v4();
        let mut plan = Plan::new(intent_id, PlanningStrategy::Deterministic);

        let step1 = Step::new("Step 1", "action1");
        let step2 = Step::new("Step 2", "action2").depends_on(step1.id);

        plan.add_step(step1);
        plan.add_step(step2);

        assert!(plan.validate().is_ok());
    }

    #[test]
    fn test_plan_cycle_detection() {
        let intent_id = Uuid::new_v4();
        let mut plan = Plan::new(intent_id, PlanningStrategy::Deterministic);

        let step1_id = Uuid::new_v4();
        let step2_id = Uuid::new_v4();

        // Create circular dependency
        let mut step1 = Step::new("Step 1", "action1");
        step1.id = step1_id;
        step1.dependencies.push(step2_id);

        let mut step2 = Step::new("Step 2", "action2");
        step2.id = step2_id;
        step2.dependencies.push(step1_id);

        plan.steps.push(step1);
        plan.steps.push(step2);

        assert!(plan.validate().is_err());
    }

    #[test]
    fn test_topological_sort() {
        let intent_id = Uuid::new_v4();
        let mut plan = Plan::new(intent_id, PlanningStrategy::Deterministic);

        let step1 = Step::new("Step 1", "action1");
        let step1_id = step1.id;
        let step2 = Step::new("Step 2", "action2").depends_on(step1_id);
        let step2_id = step2.id;
        let step3 = Step::new("Step 3", "action3").depends_on(step2_id);

        plan.add_step(step1);
        plan.add_step(step2);
        plan.add_step(step3);

        let sorted = plan.topological_sort();
        assert_eq!(sorted.len(), 3);
        assert_eq!(sorted[0].id, step1_id);
        assert_eq!(sorted[1].id, step2_id);
    }
}
